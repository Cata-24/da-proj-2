#ifndef SOLVER_H
#define SOLVER_H

/**
 * @file solver.h
 * @brief Declares the Solver class and its methods for solving the Delivery Truck Pallet Packing Optimization Problem.
 *
 * This file defines the `Solver` class, which provides interfaces for running different algorithmic
 * strategies to solve the 0/1 Knapsack problem, including brute-force, dynamic programming,
 * approximation, and integer linear programming (ILP).
 *
 */

#include "structs.h"
#include "ilp_utils.h"

using namespace std;

class Solver {
    public:

        /**
         * @brief Executes the selected algorithm based on the input data.
         *
         * This function determines which algorithm should be used to solve the Delivery Truck
         * Pallet Packing Optimization Problem. It switches on the 'algorithm' field from
         * the input data and calls the corresponding method: brute force, dynamic programming,
         * approximation, or integer linear programming (ILP). If an invalid option is provided,
         * it outputs an error message.
         *
         * @param data Struct containing input data.
         */

        void run(input_data data);

        /**
         * @brief Retrieves the result of the executed algorithm.
         *
         * This function returns the output data generated by the most recently run algorithm.
         * The output contains information such as the selected pallets and the total weight.
         *
         * @return output_data Struct holding the result of the selected algorithm execution.
         */

        output_data getOutputData();

        /**
         * @brief Approximation algorithm based on pallet profit-to-weight ratio to solve the 0/1 Knapsack problem.
         *
         * The strategy is to sort pallets by profit-to-weight ratio and then add pallets
         * to the solution while keeping the total weight within the allowed maximum.
         *
         * @param data Input data structure containing the vector of pallets and capacity (full_weight).
         */

        void approximation(input_data data);

        /**
         * @brief Solves the 0/1 Knapsack problem using a dynamic programming aproach.
         * 
         * It creates a table of size n + 1 x limit_weight + 1 and initializes all cells to 0
         * Then it goes row by row retrieving the value for each cell that will be choosen in
         * regards to the values that came before.
         * The result profit will be in the last cell.
         * 
         * @param data Has the objects weights and values, also has the limit_weight.
         */

        void dynamic_prog(input_data data);

        /**
        * @brief Solves the 0/1 Knapsack problem using brute-force recursion.
        *
        * This function initializes and calls the recursive backtracking algorithm
        * that explores all possible combinations of pallets to find the subset
        * that maximizes profit without exceeding the weight capacity.
        *
        * The solution is stored in the `result` member variable of the Solver class.
        *
        * @param data Input data containing the list of pallets and knapsack capacity.
        */

        void brute_force(input_data data);

        /**
         * @brief Solves the 0/1 Knapsack problem using Integer Linear Programming aproach.
         * 
         * It uses a python script that parses an input.txt, applies constraints based on the
         * values parsed, generates the result and then it writes the result onto an output.txt
         * That output is parsed into c++ again and placed in an output_data struct
         * 
         * @param data Has the objects weights and values, also has the limit_weight.
         */

        void ilp_aproach(input_data data);

    private:

        /**
         * @brief Each algorithm places the results in this struct that will be later retrieved to
         * be on the output
         * 
         */

        output_data result;
};

#endif //SOLVER_H
